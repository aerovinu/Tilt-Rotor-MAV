function [alphastar, nstar, exitflag] = Quadcopter_tilted_arms_max_torque(kf, km, L, nmin, nmax, alphamin, alphamax, alpha0, n0, d, beta, theta, Display, Algorithm, maxIter, StepTolerance, ConstraintTolerance)
% [alphastar, nstar, exitflag] = Quadcopter_tilted_arms_max_torque(kf, km, L, nmin, nmax, alphamin, alphamax, alpha0, n0, d, beta, theta, Display, Algorithm, maxIter, StepTolerance, ConstraintTolerance)
%QUADCOPTER_TILTED_ARMS_MAX_TORQUE find optimal tilting angles and Rotor speed
%   Optimize alpha and n so the drone produce the maximal torque in arbitrary direction d

%% Optimization of alpha and n
% maximize norm of the Torque M in an arbitrairy direction d:

% x = [alpha1 alpha2 alpha3 alpha4 n1 n2 n3 n4]

% Condition  Ax <= b        
A = []; 
b = [];                 

% Condition: Aeq.x = beq     
Aeq = [];
beq = [];

% Condition: lb <= x <= ub 
lb = [alphamin alphamin alphamin alphamin nmin nmin nmin nmin].'; % lower bound
ub = [alphamax alphamax alphamax alphamax nmax nmax nmax nmax].'; % upper bound

% initial guess:
x0 = [alpha0, n0.'];

% Objective function (maximize the 2-norm of the torque produced by the propellers in the body frame):
fun = @(x) -sqrt((- L*kf*x(5)^2*(sin(beta(1))*sin(x(1))*cos(theta(1)) - cos(x(1))*sin(theta(1))) ...
             + L*kf*x(6)^2*(sin(beta(2))*sin(x(2))* sin(theta(2)) + cos(x(2))*cos(theta(2))) ...
             + L*kf*x(7)^2*(sin(beta(3))*sin(x(3))*cos(theta(3)) - cos(x(3))* sin(theta(3))) ...
             - L*kf*x(8)^2*(sin(beta(4))*sin(x(4))*sin(theta(4)) + cos(x(4))*cos(theta(4))) ...
             -km*(sin(x(1))*sin(theta(1)) + cos(x(1))*sin(beta(1))*cos(theta(1)))*x(5)^2 ...
             + km*(sin(x(2))*(cos(theta(2))) - cos(x(2))*sin(beta(2))*sin(theta(2)))*x(6)^2 ...
             + km*(sin(x(3))*sin(theta(3)) + cos(x(3))*sin(beta(3))*cos(theta(3)))*x(7)^2 ...
             - km*(sin(x(4))*(cos(theta(4))) - cos(x(4))*sin(beta(4))*sin(theta(4)))*x(8)^2)^2 ...
           +(- L*kf*x(5)^2*(sin(beta(1))*sin(x(1))*sin(theta(1)) + cos(x(1))*cos(theta(1))) ...
             - L*kf*x(6)^2*(sin(beta(2))*sin(x(2))*cos(theta(2)) - cos(x(2))* sin(theta(2))) ...
             + L*kf*x(7)^2*(sin(beta(3))*sin(x(3))* sin(theta(3)) + cos(x(3))*cos(theta(3))) ...
             + L*kf*x(8)^2*(sin(beta(4))*sin(x(4))*cos(theta(4)) - cos(x(4))*sin(theta(4))) ...
             + km*(sin(x(1))*cos(theta(1)) - cos(x(1))*sin(beta(1))*sin(theta(1)))*x(5)^2 ...
             + km*(sin(x(2))*sin(theta(2)) + cos(x(2))*sin(beta(2))*(cos(theta(2))))*x(6)^2 ...
             - km*(sin(x(3))*cos(theta(3)) - cos(x(3))*sin(beta(3))*sin(theta(3)))*x(7)^2 ...
             - km*(sin(x(4))*sin(theta(4)) + cos(x(4))*sin(beta(4))*cos(theta(4)))*x(8)^2)^2 ...
           +(- L*kf*x(5)^2*cos(beta(1))*sin(x(1)) - L*kf*x(6)^2*cos(beta(2))*sin(x(2)) ...
             - L*kf*x(7)^2*cos(beta(3))*sin(x(3)) - L*kf*x(8)^2*cos(beta(4))*sin(x(4))...
             -km*cos(x(1))*cos(beta(1))*x(5)^2 + km*cos(x(2))*cos(beta(2))*x(6)^2 ...
             - km*cos(x(3))*cos(beta(3))*x(7)^2 + km*cos(x(4))*cos(beta(4))*x(8)^2)^2);
         
% optimization options       
options = optimoptions('fmincon', 'Display', Display, 'Algorithm',Algorithm, 'StepTolerance', StepTolerance, 'ConstraintTolerance', ConstraintTolerance);
options=optimoptions(options, 'MaxFunEvals', maxIter);
options=optimoptions(options,'MaxIter', maxIter);

% actual optimization
[xstar,fval,exitflag,output] = fmincon(fun, x0, A, b, Aeq, beq, lb, ub, @(x) nonlinconM(x, kf, km, beta, theta, L, d),  options);

% Solution of the optimization
alphastar = [xstar(1) xstar(2) xstar(3) xstar(4)];
nstar = [xstar(5) xstar(6) xstar(7) xstar(8)].';

%% Tests:
% M = Torque(kf, km, theta, beta, L, xstar);
% M0 = Torque(kf, km, theta, beta, L, x0);
% lb = lb*1.01;
% ub = 1.01*ub;
% if xstar(1)>=lb(1) && xstar(1)<=ub(1) && xstar(2)>=lb(2) && xstar(2)<=ub(2)  && xstar(3)>=lb(3) && xstar(3)<=ub(3) && xstar(4)>=lb(4) && xstar(4)<=ub(4) && xstar(5)>=lb(5) && xstar(5)<=ub(5) && xstar(6)>=lb(6) && xstar(6)<=ub(6)  && xstar(7)>=lb(7) && xstar(7)<=ub(7) && xstar(8)>=lb(8) && xstar(8)<=ub(8)
% else
%     infoM = 'lb, ub not satisfied'
%     xstar = xstar
% end
% if ~isequal(round(cross(M,d)*10^2)/10^2,[0 0 0].')
%     infoM = '~//'
% end
% if norm([xstar(5), xstar(6), xstar(7), xstar(8)]) < 100
%     leiite = 1;
% end

%% Non linear constraints function 
function [c,ceq] = nonlinconM(x, kf, km, beta, theta,  L, d)
% function [c,ceq] = nonlincon(x, kf, nmax,d, L)

%Torque produced by the propellers in the body frame
M = [(-L*kf*x(5)^2*(sin(beta(1))*sin(x(1))*cos(theta(1)) - cos(x(1))*sin(theta(1))) ...
      +L*kf*x(6)^2*(sin(beta(2))*sin(x(2))* sin(theta(2)) + cos(x(2))*cos(theta(2))) ...
      +L*kf*x(7)^2*(sin(beta(3))*sin(x(3))*cos(theta(3)) - cos(x(3))* sin(theta(3))) ...
      -L*kf*x(8)^2*(sin(beta(4))*sin(x(4))*sin(theta(4)) + cos(x(4))*cos(theta(4))) ...
      -km*(sin(x(1))*sin(theta(1)) + cos(x(1))*sin(beta(1))*cos(theta(1)))*x(5)^2 ...
      +km*(sin(x(2))*(cos(theta(2))) - cos(x(2))*sin(beta(2))*sin(theta(2)))*x(6)^2 ...
      +km*(sin(x(3))*sin(theta(3)) + cos(x(3))*sin(beta(3))*cos(theta(3)))*x(7)^2 ...
      -km*(sin(x(4))*(cos(theta(4))) - cos(x(4))*sin(beta(4))*sin(theta(4)))*x(8)^2); ...
     (-L*kf*x(5)^2*(sin(beta(1))*sin(x(1))*sin(theta(1)) + cos(x(1))*cos(theta(1))) ...
      -L*kf*x(6)^2*(sin(beta(2))*sin(x(2))*cos(theta(2)) - cos(x(2))* sin(theta(2))) ...
      +L*kf*x(7)^2*(sin(beta(3))*sin(x(3))* sin(theta(3)) + cos(x(3))*cos(theta(3))) ...
      +L*kf*x(8)^2*(sin(beta(4))*sin(x(4))*cos(theta(4)) - cos(x(4))*sin(theta(4))) ...
      +km*(sin(x(1))*cos(theta(1)) - cos(x(1))*sin(beta(1))*sin(theta(1)))*x(5)^2 ...
      +km*(sin(x(2))*sin(theta(2)) + cos(x(2))*sin(beta(2))*(cos(theta(2))))*x(6)^2 ...
      -km*(sin(x(3))*cos(theta(3)) - cos(x(3))*sin(beta(3))*sin(theta(3)))*x(7)^2 ...
      -km*(sin(x(4))*sin(theta(4)) + cos(x(4))*sin(beta(4))*cos(theta(4)))*x(8)^2); ...
     (-L*kf*x(5)^2*cos(beta(1))*sin(x(1)) - L*kf*x(6)^2*cos(beta(2))*sin(x(2)) ...
      -L*kf*x(7)^2*cos(beta(3))*sin(x(3)) - L*kf*x(8)^2*cos(beta(4))*sin(x(4))...
      -km*cos(x(1))*cos(beta(1))*x(5)^2 + km*cos(x(2))*cos(beta(2))*x(6)^2 ...
      -km*cos(x(3))*cos(beta(3))*x(7)^2 + km*cos(x(4))*cos(beta(4))*x(8)^2)];

% Constraint: c(x) <= 0
c = [];

% Constraint: ceq(x) = 0

% Torque parallel to fdes conditions -> M x fdes = 0: 
ceq(1) = M(2)*d(3) - M(3)*d(2);
ceq(2) = M(3)*d(1) - M(1)*d(3);
ceq(3) = M(1)*d(2) - M(2)*d(1);

% Force applied on MAV equal to zero condition:
% ceq(4) = T(1);
% ceq(5) = T(2);
% ceq(6) = T(3);
end
end
